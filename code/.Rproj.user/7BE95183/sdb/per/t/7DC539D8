{
    "contents" : "#################################################################################################\n# Nested logit coding assignment\n# Matt Beamer & Cheng-Yu Chan\n# 10/24/2014\n#################################################################################################\nsource('header.R')\n\n#Load data\nval <-readRDS(paste0(varSave, 'choice_values.rds'))\nlambda <-readRDS(paste0(varSave, 'lambda_values.rds'))\n\n# Simulate 10,000 choices corresponding to epsilon and eta values for each choice/bucket: \nN <- 10^5\nnBuckets <- nrow(lambda)\nnChoices <- length(unique(val$choice))\nset.seed(1023)\nepsilon <- rgev(n = nBuckets * N, xi = 0, mu = 0, beta = 1)\neta <- rgev(n = nChoices * N, xi = 0, mu = 0, beta = 1)\nk_i <- array(val[,1:2])\n\n#################################################################################################\n# 1 under the traditional specification where epsilon_k resolves before eta_i\n# We estimate the inclusive value of each bucket to choose a bucket for each simulation.\n# Then we estimate the value of each choice given the bucket selected for each simulation,\n# and select the best choice given the bucket.\n#################################################################################################\nIV <- left_join(val, lambda, by = \"bucket\") %>%\n      group_by(bucket) %>%\n      summarise(lambda = unique(lambda), iv = log(sum(exp(val/lambda)))) %>%\n      mutate(iv = lambda * iv)\n\nnest_choice <- data.frame(\n  \"bucket\" = apply(IV$iv + \n                    matrix(epsilon, nrow = nBuckets, byrow = TRUE),\n                   2, which.max)\n)\n\nitem_choice1 <- data.frame(\n  \"bucket\" = nest_choice$bucket,\n  \"choice\" = LETTERS[\n    apply(\n      matrix(\n        left_join(nest_choice,val,by=\"bucket\")$val,\n        nrow = nChoices,\n        ncol = N) + \n        matrix(eta, nrow = nChoices, byrow = TRUE),\n      2, which.max)\n  ]\n)\n\n#################################################################################################\n# 2 under the single-shot specification where epsilon_k and eta_i both resolve up front \n# We directly estimate the value of each bucket-choice combination for each simulation, \n# and select the maximum one.\n#################################################################################################\na <- matrix(eta, nrow = nChoices, byrow = TRUE)\neps <- matrix(epsilon, nrow = nChoices, byrow = TRUE)\n\nU2<-apply(mdply(k_i,\n                function(k, i) \n                  val$val[val$bucket==k & val$choice==i] + \n                  eps[k,] + \n                  lambda$lambda[k]*a[i,]\n                )%>% \n                select(c(-1, -2)),\n          2, which.max)\n\nitem_choice2 <- data.frame(\"bucket\" = val$bucket[U2],\n                           \"choice\" = val$choice[U2]\n                           )\n\n#################################################################################################\n# Estimate the probability of selecting each bucket-choice combination under each of the methods above.\n# Also estimate the covariance matrix of estimates with bootstrap.\n# Use 100 resamplings of size 100 each for the bootstrap.\n#################################################################################################\n\n# Calculates sample probabilities:\n# - \"k_i\" : bucket-choice combinations\n# - \"data\": a vector of choices\nProb <- function(k_i, data){\n  P <- mdply(k_i, \n        function(k,i) with(data, sum(bucket == k & choice == i)/nrow(data))\n    )\n  colnames(P)<- c(\"bucket\", \"choice\", \"prob\")\n  return(P)\n}\nProb1 <- Prob(k_i, item_choice1)\nProb2 <- Prob(k_i, item_choice2)\n\n\n# Bootstraps covariance matrix:\n# - \"data\": a vector of choices\n# - \"num\" : for number of resamplings\n# - \"size\": size of each sample \nb.cov <- function(data, num, size){\n  resamples <- lapply(1:num, function(i) data[sample(1:nrow(data), size, replace = TRUE),])\n  r.prob <- sapply(resamples, function(x) Prob(k_i, x)[,3])\n  covProb <- cov(t(r.prob))\n  rownames(covProb)<- paste(val$choice, val$bucket, sep = \"\")\n  colnames(covProb)<- paste(val$choice, val$bucket, sep = \"\")\n  return(covProb)\n} \n\nsigma1 <- b.cov(item_choice1, 100, 100)\nsigma2 <- b.cov(item_choice2, 100, 100)\n\n#################################################################################################\n# Compute the true, theoretical probability. \n# We first calculate the probability of selecting each bucket.\n# We then calculate the probabilty of selecting each choice within the bucket.\n# The final probability of selecting each bucket-choice combination is the above two probabilities\n# multiplied together.\n#################################################################################################\n\n# Calculates probability of selecting each bucket:\n# - \"bucket\": vector of bucket options\nProb_bucket <- function (bucket){\n  Pbucket = exp(IV$iv[bucket])/sum(exp(IV$iv))\n  return(data.frame(\"bucket\" = bucket, Pbucket))\n}\n\n# Calculates probability of selecting each choice conditional on bucket:\n# - \"choice\": scalar choice option\n# - \"bucket\": scalar bucket option\nProb_choice_bucket <- function (choice, bucket){\n  Pchoice <- exp(val$val[val$choice == choice & val$bucket == bucket])/\n              sum(exp(val$val[val$bucket == bucket]))\n  return(Pchoice)\n}\n\ntrueProb <- left_join(\n  ddply(val,.(bucket, choice), summarise, PchoiceBucket = Prob_choice_bucket(choice, bucket)),\n  Prob_bucket(1:nBuckets),\n  by = \"bucket\"\n) %>% \n  mutate(prob = PchoiceBucket * Pbucket) %>%\n  select(bucket, choice, prob) %>%\n  arrange(choice, bucket)\n\n#################################################################################################\n# We calculate the Wald statistic for our estimates using each of the two methods above.\n# The hypothesis we are testing is that our estimates are equal to the true, theoretical probs.\n# We expect to not reject the hypothesis in the first method, and to reject the hypothesis\n# in the second case. \n# Our expectations are confirmed.\n#################################################################################################\n\n# Calculates Wald test statistic:\n# - \"theta\": vector of estimated parameters\n# - \"sigma\": matrix of estimated covariance\n# - \"H0\"   : vector of null hypothesis values\nwald <- function (theta, sigma, H0){\n  W<- t(theta - H0)%*%\n      ginv(sigma) %*%\n      (theta - H0)\n  return(W)\n}\n\nW1 <- wald(Prob1$prob, sigma1, trueProb$prob)\n1 - pchisq(W1, 9) # Fail to reject the null hypothesis of equal probabilities\n\nW2 <- wald(Prob2$prob, sigma2,trueProb$prob)\n1 - pchisq(W2, 9) # Reject the null hypothesis of equal probabilities\n\n",
    "created" : 1414472142467.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1060392486",
    "id" : "7DC539D8",
    "lastKnownWriteTime" : 1414472140,
    "path" : "~/Downloads/m (1).R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}